# 03장 리액트 훅 깊게 살펴보기

## 3.1 리액트의 모든 훅 파헤치기
리액트 함수 컴포넌트에서 가장 중요한 개념은 바로 훅이다. 훅은 클래스 컴포넌트에서만 가능했던 state, ref 등 리액트의 핵심적인 기능을 함수에서도
가능하게 만들었고, 무엇보다 클래스 컴포넌트보다 간결하게 작성할 수 있어 훅이 등장한 이래로 대부분의 리액트 컴포넌트는 함수 컴포넌트로 작성되고
있을 정도로 많은 사랑을 받고 있다.

### 3.1.1 useState
useState는 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다. 만약 useState를 사용하지 않고 함수 내부에서 자체적으로
변수를 사용해 상태값을 관리한다고 가정해 보자.
```javascript
function Component() {
    let state = 'hello';
    function handleButtonClick() {
        state = 'hi'
    }
    return (
        <>
            <h1>{state}</h1>
            <button onClick={handleButtonClick}>hi</button>
        </>
    )
}
```
위 코드는 동작하지 않는다. 리액트에서 렌더링은 함수 컴포넌트의 return과 클래스 컴포넌트의 render 함수를 실행한 다음, 이 실행 결과를 이전의 리액트
트리와 비교해 리렌더링이 필요한 부분만 업데이트해 이뤄진다고 정리했다. 하지만 위의 코드는 현재 state의 값이 hi로 바뀌더라도 다시 렌더링하면 여전히
state 는 'hello' 이다. 즉, 매번 렌더링이 발생될 때마다 함수는 다시 새롭게 실행되고, 새롭게 실행되는 함수의 state는 매번 hello로 초기화된다.  
useState는 자바 스크립트의 특징 중 하나인 클로저에 의존해 구현홰 있을 것이라는 사실을 짐작할 수 있다. 

##### 게으른 초기화
일반적으로 useState에서 기본값을 선언하기 위해 useState() 인수로 원시값을 넣는 경우가 대부분일 것이다. 그러나 useState의 인수로 특정한 값을
넘기는 함수를 인수로 넣어줄 수 있다. useState에 변수 대신 함수를 넘기는 것을 게으른 초기화(lazy initialization)라고 한다.
```javascript
const [cnt, setCtn] = useState(
    Number.parseInt(window.localStorage.getItem(cacheKey)),
)

// 게으른 초기화
const [count, setCount] = useState(()=> {
    Number.parseInt((windwo.localStorage.getItem(cacheKey)))
})
```
리액트 공식 문서에서 이러한 게으른 초기화는 useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하라고 돼 있다. 이 게으른 초기화
함수는 오로지 state가 처음 만들어질 때만 사용된다. 만약 이후에 리렌더링이 발생된다면 이 함수의 실행은 무시된다.   
**리액트에서는 렌더링이 실행될 때마다 함수 컴포넌트의 함수가 다시 실행된다는 점을 명심하자.** 함수 컴포넌트의 useState의 값도 재실행된다. 그러나
우려와는 다르게 useState 내부에 함수를 넣으면 이는 최초 렌더링 이후에는 실행되지 않고 최초의 state 값을 넣을 때만 실행된다.

### 3.1.2 useEffect
useEffect의 정의를 정확하게 내리자면 useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.
그리고 이 부수 효과가 '언제' 일어나는지보다 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요하다.

##### useEffect 란?
useEffect는 자바스크립트의 proxy나 데이터 바인딩, 옵저버 같은 특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고 렌더링할 때마다 의존성에 있는
값을 보면서 이 의존성의 값이 이전과 다른게 하나라도 있으면 부수 효과를 실행하는 평범한 함수라 볼 수 있다.

##### 클린업 함수의 목적
클린업 함수는 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다.

##### 의존성 배열
의존성 배열은 보통 빈 배열을 두거나, 아예 아무런 값도 넘기지 않거나, 혹은 사용자가 직접 원하는 값을 넣어줄 수 있다. 만약 빈 배열을 둔다면 리액트가
이 useEffect는 비교할 의존성이 없다고 판단해 최초 렌더링 직후에 실행된 다음부터는 더 이상 실행되지 않는다. 아무런 값도 넘겨주지 않는다면 이때는
의존성을 비교할 필요 없이 렌더링할 때마다 실행이 필요하다고 판단해 렌더링이 발생할 때마다 실행된다. 이는 보통 컴포넌트가 렌더링됐는지 확인하기 위한
방법으로 사용된다.
```javascript
//1
function Component() {
    console.log('렌더링됨')
}

//2
function Component() {
    useEffect(()=>{
        console.log('렌더링 됨')
    })
}
```
위의 두 코드는 명백히 차이점이 있다.
1. 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 준다. useEffect 내부에서는 window 객체의 접근에 의존하는
코드를 사용해도 된다.
2. useEffect는 컴포넌트 렌더링의 부수 효과, 즉 컴포넌트의 렌더링이 완료된 이후에 실행된다. 반면 1번과 같이 함수 내부에서의 직접 실행은 컴포넌트가
렌더링되는 도중에 실행된다. 따라서 2번과는 달리 서버 사이드 렌더링의 경우에 서버에서도 실행된다. 그리고 이 작업은 함수 컴포넌트의 반환을 지연시킨다.

**useEffect 의 effect는 컴포넌트 사이드 이펙트, 즉 부수 효과를 의미한다는 것을 명심하자, useEffect는 컴포넌트가 렌더링된 후에 어떠한
부수 효과를 일으키고 싶을 때 사용하는 훅이다.**

##### useEffect를 사용할 때 주의할 점
- esling-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제하라
- useEffect의 첫 번째 인수에 함수명을 부여하라
- 거대한 useEffect를 만들지 마라
- 불필요한 외부 삼수를 만들지 마라

### 3.1.3 useMemo
useMemo는 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅이다. 흔히 리액트에서 최적화를 떠올릴 때 가장
먼저 언급되는 훅이 바로 useMemo다.


### 3.1.4 useCallback
useMemo가 값을 기억했다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다. useCallback은 특정 함수를 새로 만들지 않고 재사용한다는 의미이다.
useMemo와 useCallback의 유일한 차이는 메모이제이션을 하는 대상이 변수냐 함수냐일 뿐이다.

### 3.1.5 useRef
useRef는 useState와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있다. 그러나 useState와 구별되는
큰 차이점 두 가지를 가지고 있다.
- useRef는 반환값인 객체 내부에 있는 current로 값에 접근 또는 변경할 수 있다.
- useRef는 그 값이 변하더라도 렌더링을 발생시키지 않는다.

### 3.1.6 useContext

### 3.1.7 useReducer

### 3.1.8 useImperativeHandle

### 3.1.9 useLayoutEffect

### 3.1.10 useDebugValue

### 3.1.11 훅의 규칙

### 3.1.12 정리

------------------------------------------

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?

### 3.2.1 사용자 정의 훅

### 3.2.2 고차 컴포넌트

### 3.2.3 무엇을 써야 할까?


































































