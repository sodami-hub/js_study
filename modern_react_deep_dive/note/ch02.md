# 02장 리액트 핵심 요소 깊계 살펴보기

## 2.1 JSX란?
JSX는 리액트가 등장하면서 메타에서 소개한 새로운 구문이지만 반드시 리액트에서만 사용하라는 법은 없다. JSX는 흔히 알고 있는 XML과 유사한 내장형 구문이며,
리액트에 종속적이지 않은 독자적인 문법으로 보는 것이 옳다. 그리고 JSX는 이른바 ECMAScript 표준의 일부도 아니다. 즉, 브라우저에 의해서 실행되거나 표현되도록
만들어진 구문이 아니다. 때문에 JSX는 반드시 트랜스파일러를 거쳐야 비로소 자바스크립트 런타임이 이해할 수 있는 의미 있는 코드로 변환된다.   
JSX는 HTML이나 XML을 자바스크립트 내부에 표현하는 것이 유일한 목적은 아니다. 즉 JSX는 HTML, XML 외에도 다른 구문으로도 확장될 수 있게끔 고려돼 있으며
최대한 구문을 간결하고 친숙하게 작성할 수 있도록 설계돼 있다.

### 2.1.1 JSX의 정의
JSX는 기본적으로 JSXElement, JSXAttribute, JSXChildren, JSXString 라는 4가지 컴포넌트를 기반으로 구성된다.

##### JSXElement
가장 기본이 되는 요소, HTML의 요소(element)와 비슷한 역할을 한다. 또한 리액트에서 HTML 구문 이외의 사용자가 컴포넌트를 만들어 사용할 때에는 반드시
대문자로 시작하는 컴포넌트를 만들어야만 사용 가능하다. 그래서 JSX나 TSX는 대문자로 시작한다.

##### JSXElementName
JSXElementName 은 JSXElement의 요소 이름으로 쓸 수 있는 것을 의미한다. 이름으로 가능한 것은 자바스크립트 식별자 규칙과 동일하다. 즉, 숫자로 시작하거나
$와 _ 외의 특수문자로는 시작할 수 없다.

##### JSXAttributes
JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성을 의미하기 때문에 모든 경우에서 필수값이 아니며, 존재하지 않아도 에러가 나지 않는다.

##### JSXChildren
JSXElement의 자식 값을 나타낸다. JSX는 속성을 가진 트리 구조를 나타내기 위해 만들어졌기 때문에 JSX로 부모와 자식 관계를 나타낼 수 있다.

##### JSXString

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?
```javascript
const ComponentA = <A required={true}>Hello World</A>
const ComponentB = <>Hello World</>
```
위의 예제는 아래와 같이 변환된다.
```javascript
var ComponentA = React.CreateElement(
    A,
    {
        required:true
    },
    'Hello World'
)
var ComponentB = React.CreateElement(React.Fragment, null,'Hello World')
```

----------------------------------------

## 2.2 가상 DOM과 리액트 파이버
리액트 가상 DOM이 무엇인지, 그리고 실제 DOM에 비해 어떤 이점이 있는지 가상 DOM을 다룰 때 주의할 점이 무엇인지

### 2.2.1 DOM과 브러우저 렌더링 과정
DOM의 정의를 다루기 앞서 브라우저가 웹사이트에 접근 요청을 받고 화면을 그리는 과정에서 정확히 어떤 일이 일어나는지 알아야 된다.
1. 브라우저가 HTML 파일을 다운로드한다.
2. HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS 를 만나면 다운로드한다.
4. CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)을 만든다.
5. 브라우저는 2번의 DOM을 순회하는데 사용자 눈에 보이는 노드만 순회한다. 
6. 5번의 노드에 대한 CSS 정보를 찬고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 이 과정은 레이아웃 과정과 페인팅 과정으로 나눈다.

### 2.2.2 가상 DOM의 탄생 배경
브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다. 요즘 대다수의 앱은 렌더링된 이후에도 사용자의 인터랙션을 통해 다양한 정보를 
노출한다. 따라서 렌더링이 완료된 이후에도 웹페이지가 변하는 상황을 고려해야 한다.   
DOM 변경을 일으키고 관리하는 개발자의 입장에서 사용자의 인터랙션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자에게 너무 어려운 일이다. 그리고
대부분의 개발자는 결과적으로 만들어지는 DOM 결과물 하나만 알면 된다. 이렇게 인터랙션에 따른 DOM의 최종 결과물을 간편하게 제공하는 것은 브라우저
뿐 아니라 개발자에게도 유용하다.    
이러한 문제점을 해결하기 위해 탄생한 것이 바로 가상 DOM이다. 가상 DOM은 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM을 의미한다.
가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 부라우저의 DOM에 반영한다.   
일반적인 오해는 이러한 방식이 일반적인 DOM을 관리하는 브라우저보다 빠르다는 사실이다. 사실 무조건 빠르다는 것이 아니라 이 가상 DOM 방식은 대부분의
상황에서 웬만한 애플리케이션을 만들 수 있을 정도롤 충분히 빠르다는 것이다. 

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버
리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체다. 파이버는 파이버 재조정자(fiber reconciler)가 관리하는데, 이는 앞서 이야기한 가상 DOM과
실제 DOM을 비교해 변경 사항을 수집하며, 만약 이 둘 사이에 차이가 있으면 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.   
리액트 파이버의 목표는 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 그리고 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다.
그리고 그것을 위한 모든 과정은 비동기로 일어난다.  
  
파이버는 단순한 자바스크립트 객체로 구생돼 있다. 그리고 파이버는 리액트 요소와 유사하다. 하지만 리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만
파이버는 가급적이면 재사용된다.  
생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다. 리액트 파이버의 가상 DOM은 생각보다 단순한 자바스크립트
객체로 관리되고 있으며, 이것은 리액트의 핵심 원칙, 즉 UI를 문자열, 숫자, 배열과 같은 값으로 관리하는 것을 보여준다. 변수에 이러한 UI 관련 값을 보관하고,
리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 바로 리액트다.

##### 리액트 파이버 트리
파이버 트리는 사실 리액트 내무에서 두 개가 존재한다. 하나는 현재 모습을 담고 있는 파이버 트리이고, 다른 하나는 작업 중인 상태를 나타내는 workInProgress 트리다.
리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다. 이러한 기술을 더블 버퍼링이라고 한다.

### 2.2.4 파이버와 가상 DOM
리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며, 이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다. 이러한 비동기 작업과 달리, 실제 브라우저
구조인 DOM에 반영하는 것은 동기적으로 일어나야 하고, 또 처리하는 작업이 많아 화면에 불완전하게 표시될 수 있는 가능성이 높으므로 이러한 작업을 가상에서, 즉 메모리상에서
먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.  
**즉, 리액트 파이버 트리와 가상 DOM은 리액트 UI 렌더링 과정에서 서로 연관된 개념이지만, 서로 다른 역할을 한다. 가상 DOM은 UI의 변경 사항을 메모리에 저장하고 비교하는 데
사용되는 가상의 트리 구조이다. 반면, 리액트 파이버 트리는 가상 DOM의 노드들을 연결하고, 렌더링 및 업데이트 과정에서 필요한 작업을 관리하는 리액트의 내부 데이터 구조이다.**

---------------------------------------------------

## 2.3 클래스 컴포넌트와 함수 컴포넌트
클래스 컴포넌트에 대한 이해를 넓힐 수 있다.

### 2.3.1 클래스 컴포넌트

##### 클래스 컴포넌트의 생명주기 메서드(함수 컴포넌트의 훅과 비슷한?)
React.Component와 React.PureComponent 의 차이 `Code02-12.tsx`

##### 클래스 컴포넌트의 한계
- 데이터의 흐름을 추적하기 어렵다.
- 애플리케이션 내부 로직의 재사용이 어렵다.
- 기능이 많아질수록 컴포넌트의 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.

### 2.3.2 함수 컴포넌트

### 2.3.3 함수 컴포넌트 vs. 클래스 컴포넌트

##### 생명주기 메서드의 부재
가장 눈에 띄는 차이점은 클래스 컴포넌트의 생명주기 메서드가 함수 컴포넌트에서는 존재하지 않는다. 함수 컴포넌트는 useEffect 훅을 사용해 앞서 언급했던 생명주기 메서드인
componentDidMount, componentDidUpdate, componentWillUnmount 를 비슷하게 구현할 수 있다.

##### 함수 컴포넌트와 렌더링된 값
함수 컴포넌트는 렌더링된 값을 고정하고, 클래스 컴포넌트는 그렇지 못하다.

##### 클래스 컴포넌트를 공부해야 할까?

### 2.3.4 정리

-------------------------------------------------

## 2.4 렌더링은 어떻게 일어나는가?
브라우저의 렌더링이란 HTML, CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미한다. 그리고 리액트의 렌더링은 브라우저가 렌더링에 필요한
DOM 트리를 만드는 과정을 의미한다. 리액트도 브라우저와 마찬가지로 이 렌더링 작업을 위한 자체적인 렌더링 프로세스가 있으며, 이를 이해하는 것은 중요하다.

### 2.4.1 리액트의 렌더링이란?
리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props, state 의 값을 기반으로 어떻게 UI를
구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다. 만약 컴포넌트가 props와 state와 같은 상태값을
가지고 있지 않다면 오직 해당 컴포넌트가 반환하는 JSX 값에 기반해 렌더링이 일어나게 된다.

### 2.4.2 리액트의 렌더링이 일어나는 이유
1. 최초 렌더링
2. 리렌더링
   - 함수 컴포넌트의 useState() 의 두번째 배열 요소인 setter가 실행되는 경우
   - 함수 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
   - 컴포넌트의 key props 가 변경되는 경우
   - 부모 컴포넌트가 렌더링될 경우: 부모 컴포넌트가 리렌더링된다면 자식 컴포넌트도 무조건 리렌더링이 일어난다.

### 2.4.3 리액트의 렌더링 프로세스
먼저 앞서 JSX에서 살펴본 것 처럼 JSX 파일이 일반적인 자바스크립트 문법의 형태로 변환된다. 이러한 결과물을 수직한 다음, 리액트의 새로운 가상 트리인 가상 DOM과
비교회 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.  
이렇게 계산하는 과정을 2.2 에서 살펴본 리액트의 재조정이라고 한다. 이러한 재조정이 모두 끝나면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된
결과물이 보이게 된다.  
주목할 점은 리액트의 렌더링은 렌더 단계와 커밋 단계라는 두 단계로 분리되어 실행된다는 것이다.

### 2.4.4 렌더와 커밋
렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. 즉, 렌더링 프로세스에서 컴포넌트를 실행해(render() 또는 return) 이 결과와 이전
가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다. 여기서 비교하는 것은 크게 세 가지로, type, props, key다. 이 세 가지 중 하나라도
변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둔다.  
그 다음 커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.  
중요한 사실은 리액트의 렌더링이 일어난다고 무조건 DOM 업데이트가 일어나는 것은 아니라는 것이다. 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 즉 변경
사항을 계산했는데 아무런 변경 사항이 감지되지 않는다면 이 커밋 단계는 생략될 수 있다. 즉 리액트 렌더링은 꼭 가시적인 변경이 없어도 발생할 수 있다. 렌더
단계에서 변경 사항을 감지할 수 없다면 커밋 단계가 생략되어 브라우저의 DOM 업데이트는 일어나지 않을 수 있다.

---------------------------------------------

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
메모이제이션 기법은 언제 사용하는 것이 좋을까? 

### 2.5.1 주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자.

### 2.5.2 주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자.

### 2.5.3 결론 및 정리





























































