## ch04 - 변수
### 4.3 변수 선언
var, let, const 키워드를 사용한다. ES6 에서 let, const 키워드가 도입되기 전까지 var 키워드만 사용됐다. 먼저 var 를 살펴보고
let, const 는 나중에 자세히 알아본다.  
var 키워드는 여러 단점이 있다. 가장 큰 단점은 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다. 이로 인해 의도치 않게
전역 변수가 선언되어 심각한 부작용이 발생하기도 한다.  
자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.
1. 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined 를 할당해 초기화한다.

변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 실행 컨텍스트는 자스엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을
제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.  
var 키워드는 선언과 초기화가 동시에 진행된다. var 키워드로 선언한 변수는 undefined 로 암묵적인 초기화가 자동 수행된다.

### 4.4 변수 선언의 실행 시점과 변수 호이스팅
```javascript
console.log(score);

var score;
```
변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 하지만 참조 에러가 발생하지 않고 undefined가 출력된다. 그 이유는 변수 선언이 소스코드가 한 줄씩
순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.  
자스엔진은 코드를 한 줄씩 실행하기 앞서 먼저 소스코드의 평가 과정을 거친다. 이 과정에서 엔진은 변수 선언을 포함한 모든 선어문을 찾아서 먼저 실행한다.
즉, 자스 엔진은 변수 선언이 소스코드의 어디에 있든 다른 코드보다 먼저 실행한다.  
이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바 스크립트의 고유의 특징을 변수 호이스팅이라고 한다.

🙌 자바스크립트는 일반적으로 변수나 함수의 이름은 카멜 케이스를 사용하고, 생성자 함수, 클래스 이름에는 파스칼 케이스를 사용한다.

-----------------------------------------

## ch05 - 표현식과 문
### 5.1 값
**값(value)은 식(표현식 expression)이 평가(evaluate)되어 생성된 결과**를 말한다. 평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.  
변수는 하나의 값을 저장하기 위한 공간이다. 따라서 변수에 할당되는 것은 값이다. 값은 다양한 방법으로 생성할 수 있다. 식(10+20)으로 생성할 수도 있지만
가장 기본적인 방법은 리터럴을 사용하는 것이다.

### 5.2 리터럴
리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.

### 5.3 표현식
**표현식은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.**
```javascript
var score = 100;
```
위 예의 100은 리터럴이다. 리터럴 100은 자스 엔진에 의해 평가되어 값을 생성하므로 리터럴은 그 자체로 표현식이다.
```javascript
var score = 50 + 50;
```
50+50 은 리터럴과 연산자로 이뤄져 있다. 하지만 50+50도 평가되어 숫자 값 100을 생성하므로 표현식이다. 즉, **값으로 평가될 수 있는 문은 표현식이다.**

### 5.4 문
자바스크립트를 설명할 때 "문(statement)과 표현식(expression)"이라는 용어가 자주 등장할 것이다. 이 두가지를 확실하게 이해해야 된다.
**문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위**이다. 문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열한 것이 프로그래밍이다.  
문을 명령문이라고도 부른다. 즉, 문은 컴퓨터에 내리는 명령이다. 문이 실행되면 명령이 실행되고 무슨 일인가 일어나게 된다.
```javascript
// 변수 선언문
var x;
// 할당문
x=10;
// 함수 선언문
function foo() {}
// 조건문
if(x) { console.log(1)}
// 반복문
for (var i=0; i<3;i ++) {...}
```

### 5.6 표현식인 문과 표현식이 아닌 문
문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문이다.
이 **두가지를 구분하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것**이다. 표현식이 아닌 문은 값으로 평가할 수 없으므로 에러가 발생한다.
✨크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined 를 출력한다. 이를 완료 값이라고 한다. 완료 값은 표현식의 평가 결과가 아니다.
따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.

-----------------------------------------

## ch06 - 데이터 타입
자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 원시 타입과 객체 타입으로 분류할 수 있다.

### 6.1 숫자 타입
자바스크립트는 하나의 숫자 타입만 존재한다. 즉, **모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.**  
숫자 타입은 추가적으로 세 가지 특별한 값도 표현할 수 있다.
```javascript
console.log(10/0) // Infinity
console.log(10/-0) // -Infinity
console.log(1*'string') // NaN
```
자바스크립트는 대소문자를 구별하므로 NaN을 NAN,nan,Nan 과 같이 표현하면 에러가 발생한다.

### 6.2 문자열 타입
문자열은 0개 이상의 16비트 유니코드 문자(UTF-16) 의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.
문자열은 '',"",`` 으로 감싼다. 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다. 자스의 문자열은 원시타입이며, 변경 불가능한 값이다.

### 6.3 템플릿 리터럴
템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 테그드 템플릿 등 편리한 문자열 처리 기능을 제공한다. 템플릿 리터럴은 런타임에 일반 문자열로 변환된다.
템플릿 리터럴은 백틱(``)을 사용해서 표현한다.

#### 6.3.1 멀티라인 문자열
일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다. 일반 문자열에서 줄바꿈 등의 공백을 표현하려면 이스케이프 시퀀스를 사용해야 된다.
하지만 템플릿 리터럴(``) 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.

#### 6.3.2 표현식 삽입

### 6.5 undefined 타입
undefined 타입의 값은 undefined 가 유일하다. var 키워드로 선언한 변수는 암묵적으로 undefined 로 초기화 된다. 이 값은 개발자가 의도적으로 할당하기
위한 값이 아니라 자스 엔진이 변수를 초기화 할 때 사용하는 값이다. 변수에 값이 없다는 것을 명시하기 위해서는 null을 사용한다.

### 6.6 null 타입
null 타입의 값은 null 이 유일하다. 자스는 대소문자를 구분한다.

### 6.7 심벌 타입
심벌(symbol)은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 주로
이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.  
심벌은 Symbol 함수를 호출해 생성한다. 이때 생성된 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

### 6.8 객체 타입
중요한 것은 자스는 객체 기반의 언어이며, **자스를 이루고 있는 거의 모든 것이 객체**라는 것이다!

### 6.9 데이터 타입의 필요성
1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해서
2. 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해서
3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해서

### 6.10 동적 타이핑
#### 6.10.1 동적 타입 언어와 정적 타입 언어
자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다.
자스의 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아니라 어떠한 타입의 값이라도 자유롭게 할당할 수 있다.  
**자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론 type inference)된다.** 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.
이러한 특징을 동적 타이핑(dynamic typing)이라하며, 자스를 동적 타입 언어라고 한다.

#### 6.10.2 동적 타입 언어와 변수
동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다. 유연성은 높지만 신뢰성은 떨어진다.

- 변수는 꼭 필요한 경우에 제한적으로 사용한다.
- 변수의 유효 범위는 최대한 좁게 만들어 부작용을 억제한다.
- 전역 변수는 최대한 사용하지 않는다.
- 변수보다는 상수를 사용해 갑스이 변경을 억제한다.
- 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

-----------------------------------------

## ch07 - 연산자
연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자라고 한다.
피연산자는 값으로 평가될 수 있는 표현식이어야 한다. 그리고 펴연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.
즉, 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다. 연산자는 값으로 평가된 피연산자를 연산해 새로운 값으로 만든다.

### 7.1 산술 연산자
산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다. 산술 연산자는 피연산자의 개수에 따라
이항, 단항 산술 연산자로 구분한다.
#### 7.1.1 이항 산술 연산자
#### 7.1.2 단항 산술 연산자
1개의 피연산자를 살술 연산하여 숫자 값을 만든다. `++,--` 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.  
'+' 단항 연산자는 피연산자에 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. 그러나 숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다.  
'-' 단항 연상자는 피연산자의 부호를 반전한 값을 반환한다. + 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자를 숫자 타입으로 반환하는데 이때 부호를 반전한다.
#### 7.1.3 문자열 연결 연산자
'+' 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
```
1+true; // 2
1+false; // 1
```
이 예제에서 주목할 것은 개발자의 의도와는 상관없이 자스 엔진에 의해서 암묵적으로 타입이 자동 변환되기도 한다는 것이다. 위에서 1+true 를 연산하면 불리언 타입값인 true를 1로 타입을 강제로 변환한 후 연산을 수행한다.  
이를 암묵적 타입 변환 또는 강제 타입 변환이라고 한다. 
### 7.2 할당 연산자
할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 좌항의 변수에 값을 할당하므로 값이 변하는 부수 효과가 있다.  
그렇다면 할당문은 표혁식인 문일까? 표현식이 아닌 문일까? 다음 예제를 보겠다.
```
var x;

console.log(x=10); // 10
```
할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다. 

### 7.3 비교 연산자
#### 7.3.1 동등/일치 비교 연산자
동등 비교 `== 또는 !=` 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다. 따라서 동등 비교 연산자는 사용하지 않는 편이 좋다. 대신 일치 비교(===) 연산자를 사용한다.  
일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 주의 할 점은 NaN 이다. NaN은 자신과 일치하지 않는 유일한 값이다. 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN을 사용한다.  
숫자 0도 주의해야 한다. 자스에는 +0, -0이 있는데 이들을 비교하면 true를 반환한다.
Object.is 메서드를 사용하면 이 값들 도 정확하게 비교할 수 있다.
```
-0 === +0 // true
Object.is(-0,+0) // false

NaN === NaN // false
Object.is(NaN,NaN) // true
```

#### 7.3.2 대소 관계 비교 연산자

### 7.4 삼항 조건 연산자
### 7.5 논리 연산자
### 7.6 숨표 연산자
### 7.7 그룹 연산자

### 7.8 typeof 연산자
typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자로 null 을 연산해 보면 null 이 아닌 object를 반환하는 것을 주의해야 한다. 이것은 자바스크립트의 첫 번째 버전의 버그이다. null 타입인지 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용한다. 또 한가지 주의할 점은 선언하지 않은 식별자를 연산해보면 ReferenceError 가 발생하지 않고 undefined 를 반홚한다. 

### 7.9 지수 연산자
ES7에서 도임된 `**` 연산자로 지수 연산을 할 수 있다. 지수 연산자가 도입되기 전에는 Math.po 메서드를 사용했다.

### 7.10 그 외의 연산자
- ?. 옵셔널 체이닝 연산자
- ?? null 병합 연산자
- delete 프로퍼티 삭제 연산자
- new 생성자 함수를 호출하는 연산자
- instanceof 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
- in 프로퍼티 존재 확인

### 7.11 연산자의 부수 효과
대부분의 연산자는 다른 코드에 영향을 주지 않는다. 예를 들어 1*2 는 새로운 값 2를 생성할 뿐이다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다. 부수 효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자이다.

### 7.12 연산자 우선순위
### 7.13 연산자 결합 순서



















